        -:    0:Source:src/directed_graph.cpp
        -:    0:Programs:8
        -:    1:#include "directed_graph.h"
        -:    2:
     1001:    3:Directed::Directed(int n) : Directed_IF(n){ }
    #####:    4:Directed::Directed(int n, Edges e) : Directed_IF(n){
    #####:    5:  this->visited = new int[n+1];
    #####:    6:  for( int i=0; i<e.get_size(); i++ ){
    #####:    7:    add_edge(e[i].first, e[i].second.first, e[i].second.second);
        -:    8:  }
    #####:    9:}
        -:   10:
     1001:   11:Directed::~Directed(){}
        -:   12:
    #####:   13:void Directed::add_edge(int bg, int en){
    #####:   14:  add_edge(bg, en, 1);
    #####:   15:}
        4:   16:void Directed::add_edge(int bg, int en, int w){
        4:   17:  if(bg <= 0 or bg > this->order()){
    #####:   18:    throw std::overflow_error("Posição inicial para a aresta inválida");
        8:   19:  }if(en <= 0 or en > this->order()){
    #####:   20:    throw std::overflow_error("Posição final para a aresta inválida");
        4:   21:  }if(w == 0){
    #####:   22:      throw std::invalid_argument("Valor inválido para aresta");
        -:   23:  }
        4:   24:  if(!this->matrix[bg][en]){
        4:   25:    this->matrix[0][0]++;
        4:   26:    this->matrix[bg][0]++;
        4:   27:    this->matrix[0][en]++;
        -:   28:  }
        4:   29:  if(this->matrix[bg][en] >= 0){
        4:   30:    if(w < 0)
    #####:   31:        this->has_negative_weight++;
        -:   32:  }
        4:   33:  this->matrix[bg][en] = w;
        4:   34:  this->transverse[en][bg] = w;
        6:   35:}
