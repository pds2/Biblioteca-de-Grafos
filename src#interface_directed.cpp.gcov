        -:    0:Source:src/interface_directed.cpp
        -:    0:Programs:8
        -:    1:#include "interface_directed.h"
        -:    2:
     1001:    3:Directed_IF::Directed_IF(int n) : Graph_IF(n){
     1001:    4:  str_con_comp = new int[n+1];
     1001:    5:  transverse = new int*[n+1];
     1001:    6:  this->visited = new int[n+1];
     1001:    7:  this->sccs = UNDEFINED;
   502512:    8:  for( int i=0; i<=n; i++ ){
   501511:    9:    transverse[i] = new int[n+1];
        -:   10:  }
     1001:   11:}
     2002:   12:Directed_IF::~Directed_IF(){
     1001:   13:  delete[] str_con_comp;
  1002021:   14:  for( int i=0; i<this->order(); i++ ){
   500510:   15:    delete[] transverse[i];
        -:   16:  }
     1001:   17:  delete[] transverse;
     1001:   18:  delete[] visited;
     1001:   19:}
        -:   20:
    #####:   21:void Directed_IF::remove_edge(int bg, int en){
    #####:   22:  if(bg <= 0 or bg >= this->order()){
    #####:   23:     throw std::invalid_argument("Posição inicial para a aresta inválida");
    #####:   24:  }if(en <= 0 or en >= this->order()){
    #####:   25:     throw std::invalid_argument("Posição final para a aresta inválida");
        -:   26:  }
    #####:   27:  if(!this->matrix[bg][en]){
    #####:   28:     throw std::invalid_argument("A aresta não está no grafo");
        -:   29:  }
    #####:   30:  if(this->matrix[bg][en] < 0)
    #####:   31:     this->has_negative_weight--;
    #####:   32:  this->matrix[bg][en] = 0;
    #####:   33:  this->matrix[0][0]--;
    #####:   34:  this->matrix[bg][0]--;
    #####:   35:  this->matrix[0][en]--;
    #####:   36:}
    #####:   37:int Directed_IF::check_degree_in(int v){
    #####:   38:  if(v <= 0 or v > this->order()){
    #####:   39:      throw std::overflow_error("O vértice não está no grafo");
        -:   40:  }
    #####:   41:  return this->matrix[0][v];
        -:   42:}
    #####:   43:int Directed_IF::check_degree_out(int v){
    #####:   44:  if(v <= 0 or v > this->order()){
    #####:   45:      throw std::overflow_error("O vértice não está no grafo");
        -:   46:  }
    #####:   47:  return this->matrix[v][0];
        -:   48:}
        -:   49:
    #####:   50:int Directed_IF::reflexive(){
    #####:   51:   for(int i = 1; i <= this->order(); i++){
    #####:   52:       if(!this->matrix[i][i])
        -:   53:           return 0;
        -:   54:   }
        -:   55:   return 1;
        -:   56:}
    #####:   57:int Directed_IF::irreflexive(){
    #####:   58:    for(int i = 1; i <= this->order(); i++){
    #####:   59:        if(this->matrix[i][i])
        -:   60:            return 0;
        -:   61:    }
        -:   62:  return 1;
        -:   63:}
    #####:   64:int Directed_IF::symmetric(){
    #####:   65:    for(int i = 1; i <= this->order(); i++){
    #####:   66:        for(int j = 1; j <= i; j++){
    #####:   67:            if(this->matrix[i][j] and !this->matrix[j][i])
        -:   68:                return 0;
    #####:   69:            if(this->matrix[j][i] and !this->matrix[i][j])
        -:   70:                return 0;
        -:   71:        }
        -:   72:    }
        -:   73:  return 1;
        -:   74:}
    #####:   75:int Directed_IF::antissymetric(){
    #####:   76:    for(int i = 1; i <= this->order(); i++){
    #####:   77:        for(int j = 1; j < i; i++){
    #####:   78:            if(this->matrix[i][j] and this->matrix[j][i])
        -:   79:                return 0;
        -:   80:        }
        -:   81:    }
        -:   82:  return 1;
        -:   83:}
    #####:   84:int Directed_IF::assymetric(){
    #####:   85:  return (this->antissymetric() and this->irreflexive());
        -:   86:}
    #####:   87:int Directed_IF::transitive(){
    #####:   88:   for(int i = 1; i <= this->order(); i++){
    #####:   89:       for(int j = 1; j <= this->order(); j++){
    #####:   90:           if(this->matrix[i][j]){
    #####:   91:               for(int k = 1; k <= this->order(); k++){
    #####:   92:                   if(this->matrix[j][k] and !this->matrix[i][k])
        -:   93:                       return 0;
        -:   94:               }
        -:   95:           }
        -:   96:       }
        -:   97:   }
        -:   98:  return 1;
        -:   99:}
        -:  100:
    #####:  101:void Directed_IF::topological_order(int u, int visited[], std::stack<int> &s){
    #####:  102:    visited[u-1] = true;
    #####:  103:    for(int i = 1; i <= this->order(); i++){
    #####:  104:        if(this->matrix[u][i] and !visited[i-1])
    #####:  105:            topological_order(i, visited, s);
        -:  106:    }
    #####:  107:    s.push(u);
    #####:  108:}
    #####:  109:int *Directed_IF::topological_order(){
    #####:  110:  if(this->has_cycle())
        -:  111:      return NULL;
    =====:  112:  std::stack<int> s;
    #####:  113:  for( int i=0; this->order(); i++){
    #####:  114:    visited[i] = 0;
        -:  115:  }
    #####:  116:  for(int i = 0; i < this->order(); i++){
    #####:  117:      if(!visited[i])
    #####:  118:          topological_order(i+1, visited, s);
        -:  119:  }
    #####:  120:  int i = this->order();
    #####:  121:  while(!s.empty()){
    #####:  122:      visited[i--] = s.top();
        -:  123:      s.pop();
        -:  124:  }
    #####:  125:  return visited;
        -:  126:}
    #####:  127:int Directed_IF::has_cycle(){
    #####:  128:  this->connected();
    #####:  129:  if(this->sccs == this->order())
        -:  130:      return 0;
    #####:  131:  return 1;
        -:  132:}
    #####:  133:int Directed_IF::connected(){
    #####:  134:  this->kosaraju();
    #####:  135:  return this->sccs == 1;
        -:  136:}
    #####:  137:void Directed_IF::kosaraju(){
    #####:  138:    std::stack<int> pilha;
    #####:  139:    for( int i=0; this->order(); i++){
    #####:  140:      visited[i] = 0;
        -:  141:    }
    #####:  142:    for(int i = 1; i <= this->order(); i++){
    #####:  143:        if(!visited[i])
    #####:  144:            DFS_KOSARAJU(i, pilha);
        -:  145:    }
    #####:  146:    for( int i=0; this->order(); i++){
    #####:  147:      visited[i] = 0;
        -:  148:    }
    #####:  149:    while(pilha.size()){
    #####:  150:        int u = pilha.top();
    #####:  151:        pilha.pop();
    #####:  152:        if(!visited[u])
    #####:  153:            SCC_KOSARAJU(u,u);
        -:  154:    }
    #####:  155:}
    #####:  156:void Directed_IF::DFS_KOSARAJU(int v, std::stack<int> &pilha){
    #####:  157:    this->visited[v] = 1;
    #####:  158:    for(int i = 1; i <= this->order(); i++){
    #####:  159:        if(this->matrix[v][i] and !visited[i])
    #####:  160:            DFS_KOSARAJU(i, pilha);
        -:  161:    }
    #####:  162:    pilha.push(v);
    #####:  163:}
    #####:  164:void Directed_IF::SCC_KOSARAJU(int v, int cmp){
    #####:  165:    this->visited[v] = 1;
    #####:  166:    this->str_con_comp[v] = cmp;
    #####:  167:    for(int i = 1; i <= this->order(); i++){
    #####:  168:        if(this->transverse[v][i] and !visited[i])
    #####:  169:            SCC_KOSARAJU(i, cmp);
        -:  170:    }
    #####:  171:}
    #####:  172:int Directed_IF::get_component(int v){
    #####:  173:  if(v <= 0 or v > this->order()){
    #####:  174:      throw std::overflow_error("Este vértice não está no grafo");
        -:  175:  }
    #####:  176:  this->kosaraju();
    #####:  177:  return this->str_con_comp[v-1];
        2:  178:}
