        -:    0:Source:src/tree.cpp
        -:    0:Programs:8
        -:    1:#include "tree.h"
        -:    2:#include "edges.h"
        -:    3:#include <queue>
        -:    4:
        -:    5:// Constructors
        -:    6:// Creates a tree with n vertex and set of edges e
        -:    7:
       16:    8:Tree::Tree(int n, int new_root, Edges e) : Undirected_IF(n){
       12:    9:  parents = NULL;
       12:   10:  if(new_root < MIN_GRAPH_SIZE || new_root > this->order()){
        4:   11:    throw std::overflow_error("Posição invalida para a raiz");
        -:   12:  }
       10:   13:  root = new_root;
       20:   14:  if( e.get_size() != n-1 ){
    #####:   15:    throw std::invalid_argument("Numero de arestas invalido para a Arvore");
        -:   16:  }
      120:   17:  for( int i=0; i<e.get_size(); i++ )
       55:   18:      add_edge(e[i].first, e[i].second.first, e[i].second.second);
        -:   19:
       10:   20:  if( has_cycle() ){
        2:   21:    throw std::invalid_argument("Arestas dadas geram ciclo");
        -:   22:  }
        8:   23:  if( !connected() ){
    #####:   24:    throw std::invalid_argument("O grafo dado nao e conexo");
        -:   25:  }
        8:   26:}
        -:   27:
        4:   28:int Tree::get_root(){
        4:   29:  return root;
        -:   30:}
        4:   31:void Tree::set_root(int new_root){
        4:   32:  if(new_root < MIN_GRAPH_SIZE || new_root > this->order()){
        2:   33:    throw std::overflow_error("Posição invalida para a raiz");
        -:   34:  }
        3:   35:  if( parents != NULL ){
        1:   36:    delete[] parents;
        1:   37:    parents = NULL;
        -:   38:  }
        3:   39:  root = new_root;
        3:   40:}
        -:   41:
        -:   42:// Destructor
       14:   43:Tree::~Tree(){
        7:   44:  if( parents != NULL ){
        3:   45:    delete[] parents;
        -:   46:  }
        7:   47:}
        -:   48:
        -:   49:// Inserts edge with desired weight in the graph, connecting vertex head and tail
       55:   50:void Tree::add_edge(int head_vertex, int tail_vertex, int w){
       55:   51:    if(head_vertex < MIN_GRAPH_SIZE || head_vertex > this->order())
    #####:   52:        throw std::overflow_error("Posição inicial para a aresta inválida");
      110:   53:    if(tail_vertex < MIN_GRAPH_SIZE || tail_vertex > this->order())
    #####:   54:        throw std::overflow_error("Posição final para a aresta inválida");
        -:   55:
       55:   56:    if(!this->matrix[head_vertex][tail_vertex]){
       54:   57:        this->matrix[0][0]++;
       54:   58:        this->matrix[head_vertex][0]++;
       54:   59:        this->matrix[0][tail_vertex]++;
       54:   60:        this->matrix[0][head_vertex]++;
       54:   61:        this->matrix[tail_vertex][0]++;
        -:   62:    }
       55:   63:    if(this->matrix[head_vertex][tail_vertex] >= 0){
       55:   64:        if(w < 0)
    #####:   65:            this->has_negative_weight++;
        -:   66:    }
       55:   67:    this->matrix[head_vertex][tail_vertex] = w;
       55:   68:    this->matrix[tail_vertex][head_vertex] = w;
       55:   69:}
        -:   70:
        -:   71:// Lowest Commom Ancestor
        9:   72:int Tree::LCA(int a, int b){
        -:   73:
        9:   74:    get_parent(1);
        -:   75:
        9:   76:    bool *visited = new bool[this->order()+1];
       81:   77:    for( int i=0; i<=this->order(); i++ ){
       72:   78:      visited[i] = false;
        -:   79:    }
        -:   80:
       27:   81:    while( a!=root ){
        9:   82:      visited[a] = true;
        9:   83:      a = parents[a];
        -:   84:    }
        -:   85:
       27:   86:    while( b!=root ){
       15:   87:      if( visited[b] == true){
        6:   88:        delete[] visited;
        6:   89:        return b;
        -:   90:      }
        9:   91:      b = parents[b];
        -:   92:    }
        -:   93:
        3:   94:    delete[] visited;
        3:   95:    return root;
        -:   96:}
        -:   97:
       38:   98:int Tree::get_parent(int v){
       38:   99:  if(v < MIN_GRAPH_SIZE || v > this->order()){
    #####:  100:      throw std::overflow_error("Aresta invalida");
        -:  101:  }
       38:  102:  if( parents != NULL ){
       33:  103:    return parents[v];
        -:  104:  }
        5:  105:  parents = new int[this->order()+1];
        -:  106:
        5:  107:  dfs_parent(root, root);
        -:  108:
        5:  109:  return parents[v];
        -:  110:}
        -:  111:
       37:  112:void Tree::dfs_parent(int current, int par){
       37:  113:  parents[current] = par;
      322:  114:  for( int i=1; i<=this->order(); i++ ){
      285:  115:    if( !this->matrix[current][i] || i==par )continue;
       32:  116:    dfs_parent(i, current);
        -:  117:  }
       37:  118:}
        -:  119:
        7:  120:int Tree::num_level(){
       14:  121:  std::queue<std::pair<int,int> >q;
        7:  122:  const int end_level = -1;
        7:  123:  int par, u, levels=0;
        -:  124:
       21:  125:  q.push(std::make_pair(root, root));
       14:  126:  q.push(std::make_pair(end_level, end_level));
        -:  127:
       75:  128:  while( q.size() ){
       68:  129:    u = q.front().first;
       68:  130:    par = q.front().second;
       68:  131:    q.pop();
       91:  132:    if( u == end_level ){
       23:  133:      levels++;
       23:  134:      if( q.size() ){
       32:  135:        q.push(std::make_pair(end_level, end_level));
        -:  136:      }
       23:  137:      continue;
        -:  138:    }
      679:  139:    for( int i=1; i<=this->order(); i++ ){
      317:  140:      if( has_edge(u, i) && i != par ){
      114:  141:        q.push(std::make_pair(i, u));
        -:  142:      }
        -:  143:    }
        -:  144:  }
       14:  145:  return levels;
        -:  146:}
        -:  147:
       16:  148:int Tree::find_distance(int u, int v){
       16:  149:  find_distance(u);
       16:  150:  return distance[v];
        -:  151:}
       16:  152:int *Tree::find_distance(int v){
      160:  153:  for( int i=1; i<=this->order(); i++ ){
      144:  154:    distance[i] = -1;
        -:  155:  }
       16:  156:  distance[v] = 0;
       16:  157:  dfs_distance(v, v);
       16:  158:  return distance;
        -:  159:}
        -:  160:
      144:  161:void Tree::dfs_distance(int current, int par){
     1440:  162:  for( int i=1; i<=this->order(); i++ ){
     1296:  163:    if( has_edge(current, i) && i!=par ){
      128:  164:      distance[i] = distance[current] +1;
      128:  165:      dfs_distance(i, current);
        -:  166:    }
        -:  167:  }
      146:  168:}
