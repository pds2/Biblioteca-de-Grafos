        -:    0:Source:src/interface_base.cpp
        -:    0:Programs:8
        -:    1:#include "interface_base.h"
        -:    2:#include "constants.h"
        -:    3:
     1034:    4:Graph_IF::Graph_IF(int n) {
     1034:    5:        if(n < MIN_GRAPH_SIZE or n > MAX_GRAPH_SIZE) {
        2:    6:                throw std::overflow_error("Tamanho inválido para o grafo!");
        -:    7:        }
     1032:    8:        this->vertices = n;
     1032:    9:        this->has_negative_weight = 0;
     1032:   10:        this->distance = new int[n+1];
     1032:   11:        this->matrix = new int*[n+1];
  1005484:   12:        for(int i = 0; i <= n; i++) {
   501710:   13:                this->matrix[i] = new int[n+1];
335338710:   14:                for( int j=0; j<=n; j++ ){
334837000:   15:                  matrix[i][j] = 0;
        -:   16:                }
        -:   17:        }
     1032:   18:        this->is_connected = UNDEFINED;
     1032:   19:        this->is_bipartite = UNDEFINED;
     1032:   20:        this->is_eulerian = UNDEFINED;
     1032:   21:}
        -:   22:
     2062:   23:Graph_IF::~Graph_IF() {
   501704:   24:        while(this->vertices--) {
   500673:   25:                delete [] this->matrix[this->vertices];
        -:   26:        }
     1031:   27:        this->edges = this->has_negative_weight = 0;
     1031:   28:        delete [] this->distance;
     1031:   29:        delete [] this->matrix;
     1031:   30:}
        -:   31:
     2469:   32:int Graph_IF::has_edge(int bg, int en) {
     4937:   33:        if(bg <= 0 or bg > this->order() or en <= 0 or en > this->order()) {
        4:   34:          throw std::overflow_error("Aresta invalida");
        -:   35:        }
     2467:   36:        return this->matrix[bg][en];
        -:   37:}
        -:   38:
   504339:   39:int Graph_IF::order() {
   506884:   40:        return this->vertices;
        -:   41:}
        1:   42:int Graph_IF::size() {
        1:   43:        return this->matrix[0][0];
        -:   44:}
        9:   45:int Graph_IF::find_distance(int bg, int en){
        9:   46:    find_distance(bg);
        9:   47:    return distance[en];
        -:   48:}
       10:   49:int *Graph_IF::find_distance(int u){
       10:   50:  if(this->has_negative_weight){
    #####:   51:      throw std::invalid_argument("Não é possível realizar o dijkstra em Grafos com arestas de valores negativos");
        -:   52:  }
       10:   53:  dijkstra(u);
        9:   54:  return distance;
        -:   55:}
       10:   56:int *Graph_IF::dijkstra(int bg){
       19:   57:  if(bg <= 0 or bg > this->order()){
        1:   58:    throw std::overflow_error("Posição inicial para o caminhamento inválida");
        -:   59:  }
      127:   60:  for( int i=0; i<=this->order(); i++ ){
       59:   61:    distance[i] = INF;
        -:   62:  }
        9:   63:  this->distance[bg] = 0;
       18:   64:  std::priority_queue<std::pair<int,int> > q;
       18:   65:  q.push(std::make_pair(0, bg));
       76:   66:  while(!q.empty()){
       67:   67:      int dis = -q.top().first;
       67:   68:      int u = q.top().second;
       67:   69:      q.pop();
       67:   70:      if(dis > this->distance[u])
       17:   71:          continue;
      610:   72:      for(int i = 1; i <= this->vertices; i++){
      280:   73:          int w = this->matrix[u][i];
      280:   74:          if(!this->matrix[u][i]) continue;
      134:   75:          if(this->distance[i] > this->distance[u] + w){
       58:   76:              this->distance[i] = this->distance[u] + w;
      116:   77:              q.push(std::make_pair(-this->distance[i], i));
        -:   78:          }
        -:   79:      }
        -:   80:  }
       18:   81:  return this->distance;
        -:   82:}
        1:   83:int Graph_IF::complete() {
        6:   84:        for(int i = 1; i <= this->vertices; i++) {
        5:   85:                int in_g = matrix[0][i];
        5:   86:                int out_g = matrix[i][0];
        5:   87:                if(in_g != out_g or in_g != this->vertices - 1)
        -:   88:                        return FALSE;
        -:   89:        }
        -:   90:        return TRUE;
        -:   91:}
        1:   92:int Graph_IF::regular() {
        1:   93:        int in = matrix[0][1];
        1:   94:        int out = matrix[1][0];
        6:   95:        for(int i = 1; i <= this->vertices; i++) {
        5:   96:                if(in != matrix[0][i])
        -:   97:                        return FALSE;
        5:   98:                if(out != matrix[i][0])
        -:   99:                        return FALSE;
        -:  100:        }
        -:  101:        return TRUE;
        -:  102:}
        3:  103:int Graph_IF::subgraph(Graph_IF &g) {
        3:  104:        if(g.vertices > this->vertices)
        -:  105:                return FALSE;
        -:  106:
       17:  107:        for(int i = 1; i <= g.vertices; i++) {
       87:  108:                for(int j = 1; j <= g.vertices; j++) {
       41:  109:                        if(g.matrix[i][j] and !this->matrix[i][j])
        -:  110:                                return FALSE;
        -:  111:                }
        -:  112:        }
        -:  113:        return TRUE;
        2:  114:}
