        -:    0:Source:src/interface_base.cpp
        -:    0:Programs:99
        -:    1:#include "interface_base.h"
        -:    2:#include "constants.h"
        -:    3:
    16418:    4:Graph_IF::Graph_IF(int n) {
    16418:    5:        if(n < MIN_GRAPH_SIZE or n > MAX_GRAPH_SIZE) {
    #####:    6:                throw std::overflow_error("Tamanho inválido para o grafo!");
        -:    7:        }
    16418:    8:        this->vertices = n;
    16418:    9:        this->has_negative_weight = 0;
    16418:   10:        this->distance = new int[n+1];
    16418:   11:        this->matrix = new int*[n+1];
 16086406:   12:        for(int i = 0; i <= n; i++) {
  8026785:   13:                this->matrix[i] = new int[n+1];
5365414892:   14:                for( int j=0; j<=n; j++ ){
5357388107:   15:                  matrix[i][j] = 0;
        -:   16:                }
        -:   17:        }
    16418:   18:        this->is_connected = UNDEFINED;
    16418:   19:        this->is_bipartite = UNDEFINED;
    16418:   20:        this->is_eulerian = UNDEFINED;
    16418:   21:}
        -:   22:
    32804:   23:Graph_IF::~Graph_IF() {
  8026689:   24:        while(this->vertices--) {
  8010287:   25:                delete [] this->matrix[this->vertices];
        -:   26:        }
    16402:   27:        this->edges = this->has_negative_weight = 0;
    16402:   28:        delete [] this->distance;
    16402:   29:        delete [] this->matrix;
    16402:   30:}
        -:   31:
    38731:   32:int Graph_IF::has_edge(int bg, int en) {
    77462:   33:        if(bg <= 0 or bg > this->order() or en <= 0 or en > this->order()) {
    #####:   34:          throw std::overflow_error("Aresta invalida");
        -:   35:        }
    38731:   36:        return this->matrix[bg][en];
        -:   37:}
        -:   38:
  8068870:   39:int Graph_IF::order() {
  8108833:   40:        return this->vertices;
        -:   41:}
       16:   42:int Graph_IF::size() {
       16:   43:        return this->matrix[0][0];
        -:   44:}
      144:   45:int Graph_IF::find_distance(int bg, int en){
      144:   46:    find_distance(bg);
      144:   47:    return distance[en];
        -:   48:}
      144:   49:int *Graph_IF::find_distance(int u){
      144:   50:  if(this->has_negative_weight){
    #####:   51:      throw std::invalid_argument("Não é possível realizar o dijkstra em Grafos com arestas de valores negativos");
        -:   52:  }
      144:   53:  dijkstra(u);
      144:   54:  return distance;
        -:   55:}
      144:   56:int *Graph_IF::dijkstra(int bg){
      288:   57:  if(bg <= 0 or bg > this->order()){
    #####:   58:    throw std::overflow_error("Posição inicial para o caminhamento inválida");
        -:   59:  }
     2032:   60:  for( int i=0; i<=this->order(); i++ ){
      944:   61:    distance[i] = INF;
        -:   62:  }
      144:   63:  this->distance[bg] = 0;
      288:   64:  std::priority_queue<std::pair<int,int> > q;
      288:   65:  q.push(std::make_pair(0, bg));
     1216:   66:  while(!q.empty()){
     1072:   67:      int dis = -q.top().first;
     1072:   68:      int u = q.top().second;
     1072:   69:      q.pop();
     1072:   70:      if(dis > this->distance[u])
      272:   71:          continue;
     9760:   72:      for(int i = 1; i <= this->vertices; i++){
     4480:   73:          int w = this->matrix[u][i];
     4480:   74:          if(!this->matrix[u][i]) continue;
     2144:   75:          if(this->distance[i] > this->distance[u] + w){
      928:   76:              this->distance[i] = this->distance[u] + w;
     1856:   77:              q.push(std::make_pair(-this->distance[i], i));
        -:   78:          }
        -:   79:      }
        -:   80:  }
      288:   81:  return this->distance;
        -:   82:}
       16:   83:int Graph_IF::complete() {
       96:   84:        for(int i = 1; i <= this->vertices; i++) {
       80:   85:                int in_g = matrix[0][i];
       80:   86:                int out_g = matrix[i][0];
       80:   87:                if(in_g != out_g or in_g != this->vertices - 1)
        -:   88:                        return FALSE;
        -:   89:        }
        -:   90:        return TRUE;
        -:   91:}
       16:   92:int Graph_IF::regular() {
       16:   93:        int in = matrix[0][1];
       16:   94:        int out = matrix[1][0];
       96:   95:        for(int i = 1; i <= this->vertices; i++) {
       80:   96:                if(in != matrix[0][i])
        -:   97:                        return FALSE;
       80:   98:                if(out != matrix[i][0])
        -:   99:                        return FALSE;
        -:  100:        }
        -:  101:        return TRUE;
        -:  102:}
       48:  103:int Graph_IF::subgraph(Graph_IF &g) {
       48:  104:        if(g.vertices > this->vertices)
        -:  105:                return FALSE;
        -:  106:
      272:  107:        for(int i = 1; i <= g.vertices; i++) {
     1392:  108:                for(int j = 1; j <= g.vertices; j++) {
      656:  109:                        if(g.matrix[i][j] and !this->matrix[i][j])
        -:  110:                                return FALSE;
        -:  111:                }
        -:  112:        }
        -:  113:        return TRUE;
       32:  114:}
