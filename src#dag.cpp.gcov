        -:    0:Source:src/dag.cpp
        -:    0:Programs:99
        -:    1:#include "dag.h"
        -:    2:
    #####:    3:DAG::DAG(int n) : Directed_IF(n){}
    #####:    4:DAG::DAG(int n, Edges e): Directed_IF(n){
    #####:    5:  for( int i=0; i<e.get_size(); i++ ){
    #####:    6:    add_edge_useful(e[i].first, e[i].second.first, e[i].second.second);
        -:    7:  }
    #####:    8:}
    #####:    9:DAG::~DAG(){ }
    #####:   10:void DAG::add_edge_useful(int head_vertex, int tail_vertex, int w){
    #####:   11:  if(head_vertex < MIN_GRAPH_SIZE || head_vertex > this->order())
    #####:   12:      throw std::overflow_error("Posição inicial para a aresta inválida");
    #####:   13:  if(tail_vertex < MIN_GRAPH_SIZE || tail_vertex > this->order())
    #####:   14:      throw std::overflow_error("Posição final para a aresta inválida");
    #####:   15:  if(!this->matrix[head_vertex][tail_vertex]){
    #####:   16:      this->matrix[0][0]++;
    #####:   17:      this->matrix[head_vertex][0]++;
    #####:   18:      this->matrix[0][tail_vertex]++;
    #####:   19:      this->matrix[0][head_vertex]++;
    #####:   20:      this->matrix[tail_vertex][0]++;
        -:   21:  }
    #####:   22:  if(this->matrix[head_vertex][tail_vertex] >= 0){
    #####:   23:      if(w < 0)
    #####:   24:          this->has_negative_weight++;
        -:   25:  }
    #####:   26:  this->matrix[head_vertex][tail_vertex] = w;
    #####:   27:  this->matrix[tail_vertex][head_vertex] = w;
    #####:   28:}
    #####:   29:void DAG::add_edge(int head_vertex, int tail_vertex){
    #####:   30:  add_edge(head_vertex, tail_vertex, DEFAULT_EDGE_WEIGHT);
    #####:   31:}
    #####:   32:void DAG::add_edge(int head_vertex, int tail_vertex, int w){
    #####:   33:    add_edge_useful(head_vertex, tail_vertex, w);
    #####:   34:    if( has_cycle() ){
    #####:   35:      throw std::invalid_argument("Aresta inserida gera ciclo");
        -:   36:    }
    #####:   37:}
    #####:   38:int DAG::find_distance(int u, int v){
    #####:   39:  find_distance(u);
    #####:   40:  return distance[v];
        -:   41:}
    #####:   42:int *DAG::find_distance(int v){
    #####:   43:  if(v <= 0 or v > this->order()){
    #####:   44:    throw std::overflow_error("Posição inicial para o caminhamento inválida");
        -:   45:  }
    #####:   46:  int *topos = topological_order();
        -:   47:
    #####:   48:  for(int i = 0; i <= this->order(); i++){
    #####:   49:        distance[i] = INF;
        -:   50:  }
    #####:   51:  distance[v] = 0;
        -:   52:
    #####:   53:  for( int i=1; i<=this->order(); i++ ){
    #####:   54:    if( distance[i] == INF )continue;
    #####:   55:    for( int j=1; j<=this->order(); j++){
    #####:   56:      if( !has_edge(topos[i], j) )continue;
    #####:   57:      if( distance[j] > distance[topos[i]] + has_edge(topos[i], j)){
    #####:   58:        distance[j] = distance[topos[i]] + has_edge(topos[i], j);
        -:   59:      }
        -:   60:    }
        -:   61:  }
    #####:   62:  return distance;
       32:   63:}
