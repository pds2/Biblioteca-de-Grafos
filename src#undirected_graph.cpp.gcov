        -:    0:Source:src/undirected_graph.cpp
        -:    0:Programs:8
        -:    1:#include "undirected_graph.h"
        -:    2:#include "tree.h"
        -:    3:
        -:    4:// Constructors
        -:    5:// Creates a undirected graph with n vertex
        7:    6:Undirected::Undirected(int n) : Undirected_IF(n){
        5:    7:  rep = new int[n+1];
        5:    8:}
        -:    9:
        -:   10:// Creates a undirected graph with n vertex and set of edges e
       14:   11:Undirected::Undirected(int n, Edges e) : Undirected_IF(n){
      131:   12:    for( int i=0; i<e.get_size(); i++ )
      117:   13:        add_edge(e[i].first, e[i].second.first, e[i].second.second);
       14:   14:    rep = new int[n+1];
       14:   15:}
        -:   16:
        -:   17:// Destructor
       39:   18:Undirected::~Undirected(){
       19:   19:  delete[] rep;
       20:   20:}
        -:   21:
        -:   22:// Inserts edge with weight 1 in the graph, connecting vertex head and tail
        2:   23:void Undirected::add_edge(int head_vertex, int tail_vertex){
        2:   24:    this->add_edge(head_vertex, tail_vertex, DEFAULT_EDGE_WEIGHT);
        2:   25:}
        -:   26:
        -:   27:// Inserts edge with desired weight in the graph, connecting vertex head and tail
      122:   28:void Undirected::add_edge(int head_vertex, int tail_vertex, int w){
        -:   29:    // Treats overflow cases for edge position
      122:   30:    if(head_vertex < MIN_GRAPH_SIZE || head_vertex > this->order())
    #####:   31:        throw std::overflow_error("Posição inicial para a aresta inválida");
      244:   32:    if(tail_vertex < MIN_GRAPH_SIZE || tail_vertex > this->order())
    #####:   33:        throw std::overflow_error("Posição final para a aresta inválida");
        -:   34:
      122:   35:    if(!this->matrix[head_vertex][tail_vertex]) {
       92:   36:        this->matrix[0][0]++;
       92:   37:        this->matrix[head_vertex][0]++;
       92:   38:        this->matrix[0][tail_vertex]++;
       92:   39:        this->matrix[0][head_vertex]++;
       92:   40:        this->matrix[tail_vertex][0]++;
        -:   41:    }
        -:   42:    // Treats negative weight cases
      122:   43:    if(this->matrix[head_vertex][tail_vertex] >= 0) {
      122:   44:        if(w < 0)
        2:   45:            this->has_negative_weight++;
        -:   46:    }
      122:   47:    this->matrix[head_vertex][tail_vertex] = w;
      122:   48:    this->matrix[tail_vertex][head_vertex] = w;
      122:   49:}
        -:   50:
        -:   51:// Removes edge that connects vertex head and tail
        3:   52:void Undirected::remove_edge(int head_vertex, int tail_vertex){
        -:   53:    // Treats overflow cases for edge position
        3:   54:    if(head_vertex < MIN_GRAPH_SIZE || head_vertex > this->order())
    #####:   55:        throw std::overflow_error("Posição inicial para a aresta inválida");
        3:   56:    if(head_vertex < MIN_GRAPH_SIZE || tail_vertex > this->order())
    #####:   57:        throw std::overflow_error("Posição final para a aresta inválida");
        -:   58:
        3:   59:    if (this->matrix[head_vertex][tail_vertex] != 0) {
        3:   60:        this->matrix[0][0]--;
        3:   61:        this->matrix[head_vertex][0]--;
        3:   62:        this->matrix[0][tail_vertex]--;
        3:   63:        this->matrix[0][head_vertex]--;
        3:   64:        this->matrix[tail_vertex][0]--;
        3:   65:        this->matrix[head_vertex][tail_vertex] = 0;
        3:   66:        this->matrix[tail_vertex][head_vertex] = 0;
        -:   67:    }
        3:   68:}
        -:   69:
        1:   70:void Undirected::build(){
        7:   71:  for( int i=0; i<=this->order(); i++ ){
        6:   72:    rep[i] = i;
        -:   73:  }
        1:   74:}
        4:   75:void Undirected::unite(int u, int v){
       12:   76:  rep[find(u)] = find(v);
        4:   77:}
       19:   78:int Undirected::find(int a){
       47:   79:  return rep[a] == a ? a : rep[a] = find(rep[a]);
        -:   80:}
        -:   81:
        1:   82:Tree *Undirected::kruskal(){
        1:   83:  build();
        2:   84:  Edges ed;
        1:   85:  for( int i=1; i<=this->order(); i++ ){
       15:   86:    for( int j=i+1; j<=this->order(); j++ ){
       10:   87:      if( !has_edge(i, j) )continue;
       10:   88:      ed.insert(i, j, has_edge(i, j));
        -:   89:    }
        -:   90:  }
        1:   91:  ed.sort();
        -:   92:
        2:   93:  Edges new_tree;
       11:   94:  for( int i=0; i<ed.get_size(); i++ ){
       30:   95:    if( find(ed[i].first) != find(ed[i].second.first) ){
        4:   96:      unite(ed[i].first, ed[i].second.first);
        4:   97:      new_tree.insert(ed[i].first, ed[i].second.first, ed[i].second.second);
        -:   98:    }
        -:   99:  }
        -:  100:
        3:  101:  Tree *ret = new Tree(this->order(), 1, new_tree);
        -:  102:
        2:  103:  return ret;
        2:  104:}
