        -:    0:Source:src/undirected_graph.cpp
        -:    0:Programs:99
        -:    1:#include "undirected_graph.h"
        -:    2:#include "tree.h"
        -:    3:
        -:    4:// Constructors
        -:    5:// Creates a undirected graph with n vertex
       28:    6:Undirected::Undirected(int n) : Undirected_IF(n){
       28:    7:  rep = new int[n+1];
       28:    8:}
        -:    9:
        -:   10:// Creates a undirected graph with n vertex and set of edges e
       98:   11:Undirected::Undirected(int n, Edges e) : Undirected_IF(n){
      917:   12:    for( int i=0; i<e.get_size(); i++ )
      819:   13:        add_edge(e[i].first, e[i].second.first, e[i].second.second);
       98:   14:    rep = new int[n+1];
       98:   15:}
        -:   16:
        -:   17:// Destructor
      259:   18:Undirected::~Undirected(){
      126:   19:  delete[] rep;
      133:   20:}
        -:   21:
        -:   22:// Inserts edge with weight 1 in the graph, connecting vertex head and tail
       14:   23:void Undirected::add_edge(int head_vertex, int tail_vertex){
       14:   24:    this->add_edge(head_vertex, tail_vertex, DEFAULT_EDGE_WEIGHT);
       14:   25:}
        -:   26:
        -:   27:// Inserts edge with desired weight in the graph, connecting vertex head and tail
      854:   28:void Undirected::add_edge(int head_vertex, int tail_vertex, int w){
        -:   29:    // Treats overflow cases for edge position
      854:   30:    if(head_vertex < MIN_GRAPH_SIZE || head_vertex > this->order())
    #####:   31:        throw std::overflow_error("Posição inicial para a aresta inválida");
     1708:   32:    if(tail_vertex < MIN_GRAPH_SIZE || tail_vertex > this->order())
    #####:   33:        throw std::overflow_error("Posição final para a aresta inválida");
        -:   34:
      854:   35:    if(!this->matrix[head_vertex][tail_vertex]) {
      644:   36:        this->matrix[0][0]++;
      644:   37:        this->matrix[head_vertex][0]++;
      644:   38:        this->matrix[0][tail_vertex]++;
      644:   39:        this->matrix[0][head_vertex]++;
      644:   40:        this->matrix[tail_vertex][0]++;
        -:   41:    }
        -:   42:    // Treats negative weight cases
      854:   43:    if(this->matrix[head_vertex][tail_vertex] >= 0) {
      854:   44:        if(w < 0)
       14:   45:            this->has_negative_weight++;
        -:   46:    }
      854:   47:    this->matrix[head_vertex][tail_vertex] = w;
      854:   48:    this->matrix[tail_vertex][head_vertex] = w;
      854:   49:}
        -:   50:
        -:   51:// Removes edge that connects vertex head and tail
       21:   52:void Undirected::remove_edge(int head_vertex, int tail_vertex){
        -:   53:    // Treats overflow cases for edge position
       21:   54:    if(head_vertex < MIN_GRAPH_SIZE || head_vertex > this->order())
    #####:   55:        throw std::overflow_error("Posição inicial para a aresta inválida");
       21:   56:    if(head_vertex < MIN_GRAPH_SIZE || tail_vertex > this->order())
    #####:   57:        throw std::overflow_error("Posição final para a aresta inválida");
        -:   58:
       21:   59:    if (this->matrix[head_vertex][tail_vertex] != 0) {
       21:   60:        this->matrix[0][0]--;
       21:   61:        this->matrix[head_vertex][0]--;
       21:   62:        this->matrix[0][tail_vertex]--;
       21:   63:        this->matrix[0][head_vertex]--;
       21:   64:        this->matrix[tail_vertex][0]--;
       21:   65:        this->matrix[head_vertex][tail_vertex] = 0;
       21:   66:        this->matrix[tail_vertex][head_vertex] = 0;
        -:   67:    }
       21:   68:}
        -:   69:
        7:   70:void Undirected::build(){
       49:   71:  for( int i=0; i<=this->order(); i++ ){
       42:   72:    rep[i] = i;
        -:   73:  }
        7:   74:}
       28:   75:void Undirected::unite(int u, int v){
       84:   76:  rep[find(u)] = find(v);
       28:   77:}
      133:   78:int Undirected::find(int a){
      329:   79:  return rep[a] == a ? a : rep[a] = find(rep[a]);
        -:   80:}
        -:   81:
        7:   82:Tree *Undirected::kruskal(){
        7:   83:  build();
       14:   84:  Edges ed;
        7:   85:  for( int i=1; i<=this->order(); i++ ){
      105:   86:    for( int j=i+1; j<=this->order(); j++ ){
       70:   87:      if( !has_edge(i, j) )continue;
       70:   88:      ed.insert(i, j, has_edge(i, j));
        -:   89:    }
        -:   90:  }
        7:   91:  ed.sort();
        -:   92:
       14:   93:  Edges new_tree;
       77:   94:  for( int i=0; i<ed.get_size(); i++ ){
      210:   95:    if( find(ed[i].first) != find(ed[i].second.first) ){
       28:   96:      unite(ed[i].first, ed[i].second.first);
       28:   97:      new_tree.insert(ed[i].first, ed[i].second.first, ed[i].second.second);
        -:   98:    }
        -:   99:  }
        -:  100:
       21:  101:  Tree *ret = new Tree(this->order(), 1, new_tree);
        -:  102:
       14:  103:  return ret;
       14:  104:}
